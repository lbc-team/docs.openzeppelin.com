= 创建可升级的Solidity智能合约

*OpenZeppelin CLI* 允许你用命令行的方式升级智能合约，你也可以直接使用JavaScript来升级，但还有第三种用法：直接从其他合约创建一个新的可升级合约。

在本指南中，我们将要学习如何创建一个合约 https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)[工厂] ，工厂中生产出的合约就可以升级。

[NOTE]
====
这个指南中使用了OpenZeppelin工具的高级用法，同时要求用户熟悉Solidity，区块链的开发和OpenZeppelin CLI。

如果想要复习这个主题，可以参考智能合约的部署和交互。
====

== 配置

首先使用CLI来初始化OpenZeppelin项目

[source,console]
----
$ npx oz init creating-from-solidity 1.0.0
----

项目的名称非常重要，因为我们将会在接下来的Solidity代码中用到。

接下来我们可以编写 `Product` 的代码，它是一个用来存储变量的简单合约。 `Product` 合约就是我们的合约工厂将要创建的合约。

[source,solidity]
----
// contracts/Product.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.5.0;

import "@openzeppelin/upgrades/contracts/Initializable.sol";


contract Product is Initializable {
    uint256 public value;

    function initialize(uint256 _value) public initializer {
        value = _value;
    }
}
----

这里需要 `Factory` 参与进来：我们将要把项目中的 `App` 合约提供给它，并且用它来创建新的可升级的 `Product` 合约的实例。这里就是项目名称用到的地方：你需要把项目名称提供给 `App` 合约：

[source,solidity]
----
// contracts/Factory.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.5.0;

import "@openzeppelin/upgrades/contracts/Initializable.sol";
import "@openzeppelin/upgrades/contracts/application/App.sol";


contract Factory is Initializable {
    App private app;

    event InstanceCreated(address);

    function initialize(App _app) public initializer {
        app = _app;
    }

    function createInstance(bytes memory _data) public {
        string memory packageName = "creating-from-solidity";
        string memory contractName = "Product";
        address admin = msg.sender;

        address product = address(
            app.create(packageName, contractName, admin, _data)
        );

        emit InstanceCreated(product);
    }
}
----

== 把工厂和App连接起来

我们需要将 `App` 的地址提供给 `Factory` 的 `initialize` 方法。`App` 是你的项目在链上的表示形式，所以必须像这样明确的发布出来以便于我们使用。

要做到这一点，我们首先需要将 `Product` 合约 `add` 到我们的 `App` 中（这样的话就可以部署新的合约），接下来 `push` 或者部署基本合约，最终将整个项目 `publish` 到区块链上。

[source,console]
----
$ npx oz add Product
✓ Compiled contracts with solc 0.5.17 (commit.d19bba13)
✓ Added contract Product
$ npx oz push
Nothing to compile, all contracts are up to date.
? Pick a network development
✓ Contract Product deployed
All implementations have been deployed
$ npx oz publish
? Pick a network development
✓ Project structure deployed
✓ Registering Product at 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8Ab in directory
✓ Published to dev-1591071938836!
----

现在 `App` 已经发布好了，并且 `Product` 也在 `App` 中注册了。我们就可以使用它了！进入到你的项目的网络配置文件，然后找到 `App` 这一项：

```json
// .openzeppelin/dev-1591071938836.json
  ...
  "app": {
    "address": "0x5b1869D9A4C187F2EAa108f3062412ecf0526b24"
  },
  ...
```

拿到 `App` 的地址后，我们可以使用 `oz deploy` 来部署 `Factory` 合约：

[source,console]
----
$ npx oz deploy
Nothing to compile, all contracts are up to date.
? Choose the kind of deployment upgradeable
? Pick a network development
? Pick a contract to deploy Factory
✓ Added contract Factory
✓ Contract Factory deployed
All implementations have been deployed
? Call a function to initialize the instance after creating it? Yes
? Select which function initialize(_app: address)
? _app: address: 0x5b1869D9A4C187F2EAa108f3062412ecf0526b24
✓ Setting everything up to create contract instances
✓ creating-from-solidity Factory instance created at 0x9b1f7F645351AF3631a656421eD2e40f2802E6c0
To upgrade this instance run 'oz upgrade'
0x9b1f7F645351AF3631a656421eD2e40f2802E6c0
----

[encoding-call-data]
== 编译调用数据

我们的 `Factory` 合约中的 `createInstance` 方法已经可以正常使用了，但是还有一些遗漏： `Product` 的初始化数据。

回想一下 `Product` 有一个 `initialize` 方法：当创建一个新的合约时，我们需要确保调用时传入正确的参数。

[source,solidity]
----
// contracts/Product.sol
    ...
    function initialize(uint256 _value) public initializer {
        value = _value;
    }
    ...
----

OpenZeppelin升级提供了JavaScript功能函数用于： `encodeCall` 。它接收一个方法名，一个存放参数类型的数组和一个存放参数的数组，并根据方法的调用输出相关的数据。

让我们使用42这个数字来进行初始化并得到调用数据：

[source,console]
----
$ node
> const { encodeCall } = require('@openzeppelin/upgrades');
> encodeCall('initialize', ['uint256'], [42]);
'0xfe4b84df000000000000000000000000000000000000000000000000000000000000002a'
----

== 创建实例合约

使用 <<encoding-call-data, 我们刚才生成的>> 调用数据我们就可以使用 `Factory` 来创建一个新的 `Product` 。

[source,console]
----
$ npx oz send-tx
? Pick a network development
? Pick an instance Factory at 0x9b1f7F645351AF3631a656421eD2e40f2802E6c0
? Select which function createInstance(_data: bytes)
? _data: bytes: 0xfe4b84df000000000000000000000000000000000000000000000000000000000000002a
✓ Transaction successful. Transaction hash: 0x803969c85bb93058ae7deecfaab53ba78b79161bde4fb168c174e949a8698e71
Events emitted:
 - InstanceCreated(0x3c63250aFA2470359482d98749f2d60D2971c818)
----

我们现在就使用 `Factory` 合约创建了一个新的可升级合约 `Product` ！要注意的是，提供给 `createInstance` 的数据是我们使用 `encodeCall` 生成的。
